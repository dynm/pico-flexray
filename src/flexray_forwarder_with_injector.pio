; --------------- Program 1: The Forwarder with Injector ---------------

.program flexray_forwarder_with_injector
.fifo tx
.mov_status txfifo < 1
.out 1 left auto 32
.define public IDLE_COUNT 10

.wrap_target
entry_point:
    set pins, 1
    mov x, status  ; check fifo, default recessive
    ; when bus idle, the SM will stall on wait 0 pin 0,
    ; if now the status get 0,
    jmp !x, injector_mode ; if fifo is not empty, jump to injector mode

; --------------------------- Forwarder Mode ---------------------------
    wait 0 pin 0; wait recessive
accept_fes:
    set pins, 0
dominant_state:
    jmp pin, entry_point ; rising edge, back to main decision point
    jmp dominant_state   ; keep recessive

; --------------------------- Injector Mode ---------------------------
; the path is activated on FSS rising edge,
injector_mode:
    ; when detect FSS rising edge
    ; 1. jmp to entry_point
    ; 2. set pins 1
    ; 3,4. jmp injector_mode
    pull               ; if any data remain in osr, discard it
    out y, 32          ; first word is count
    wait 0 pin 0     ; wait BSS low
    set pins, 0
    jmp skip_bss_high

inject_loop:
    set pins, 1 [9]
    set pins, 0 [1]
skip_bss_high:
    set pins, 0 [6]
    set x, 6
out_1_byte:
    out pins, 1 [8]
    jmp x-- out_1_byte  

    out pins, 1 [8]
    jmp y--, inject_loop
    set pins, 0
    jmp accept_fes
.wrap
% c-sdk {
void flexray_forwarder_with_injector_program_init(PIO pio, uint sm, uint offset, uint rx_pin, uint tx_pin) {
    // Now, let PIO take control of the pins.
    pio_gpio_init(pio, tx_pin);
    pio_gpio_init(pio, rx_pin);
    gpio_pull_up(tx_pin);
    pio_sm_set_consecutive_pindirs(pio, sm, tx_pin, 1, true);
    pio_sm_set_consecutive_pindirs(pio, sm, rx_pin, 1, false);

    pio_sm_config c = flexray_forwarder_with_injector_program_get_default_config(offset);

    sm_config_set_set_pins(&c, tx_pin, 1);
    sm_config_set_out_pins(&c, tx_pin, 1);

    sm_config_set_in_pins(&c, rx_pin);
    sm_config_set_jmp_pin(&c, rx_pin);
    float div = (float)clock_get_hz(clk_sys) / (10 * 1000000 * 10);
    sm_config_set_clkdiv(&c, div);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}


%}
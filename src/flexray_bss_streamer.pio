; A PIO program that continuously finds FlexRay frames, streams them,
; and raises an interrupt after each one, without ever stopping.

.program flexray_bss_streamer
.side_set 1 opt ; Side-set pin 0 is used to control the transmitter enable (TX_EN)

.define public IDLE_COUNT 19     ; For 20 * 10 = 200 cycle initial idle check.
; Set timeout counter to 31 (max value for a 5-bit immediate).
; This allows for 32 iterations of the 2-cycle polling loop, giving a
; timeout of 64 PIO cycles (~6.4 FlexRay bit times). This is ample
; time to find a BSS and a robust threshold for detecting EOP.
.define public BSS_SEARCH_TIMEOUT 31
.define public FLUSH_COUNT 31


.define public DATA_BITS 7       ; Loop 8 times for 8 bits.

entry_point:
    ; mov isr, null
    set x, IDLE_COUNT           
    ; --- 1. Initial Bus Idle Check ---
idle_loop:
    jmp pin is_high
    jmp entry_point
is_high:
    nop [7]
    nop
    jmp x-- idle_loop

    ; --- 2. Frame Start Synchronization (TSS/FSS) ---
    wait 1 pin 0                ; nothing, wait for stable high
    wait 0 pin 0                ; waiting for TSS low
    wait 1 pin 0   side 1       ; before FSS high detected, we are in TSS, enable TX_EN by side set
    nop [7]                     ; consume fss high
    nop [1]
    ; --- 3. Entry point for finding any BSS (first or subsequent) ---
find_bss_entry_point:
    ; Prime the timeout counter for the high-speed search.
    set x, BSS_SEARCH_TIMEOUT   ; 1 cycle for BSS high

    ; --- 4. High-Frequency (50MHz) Polling Loop for BSS Falling Edge ---
find_edge_loop:
    jmp pin high_path           ; 1 cycle. If pin is HIGH, jump.
    ; --- PATH FOR LOW BIT (Edge Found!) ---
    jmp found_edge              ; 1 cycle. If pin is LOW, we found the edge!

high_path:
    jmp x-- find_edge_loop      ; 1 cycle. Pin was HIGH, decrement timeout, loop again.
    ; --- EOP DETECTED (Timeout) ---
    ; 'jmp x--' failed. We searched for ~6 bit times without finding a falling edge.
    ; jmp frame_end
    jmp flush_isr side 0       ; frame end, disable TX_EN by side set

found_edge:
    ; --- SYNC POINT! ---
    ; We have a high-precision sync point at the start of a BSS '0' bit.
    ; The path to get here took 2 cycles (`jmp pin` fail + `jmp found_edge`).
    ; To sample in the center of the NEXT data bit (1.5 bits = 15 cycles away),
    ; we need to wait 15 - 2 = 13 cycles.
    ; 1st or 2nd of the over-sampled low state for BSS
    nop [7]                    ; Wait 13 cycles. side=1: Sampling byte.
    nop [4]

    ; --- 5. Synchronized 8-Bit Byte Sample ---
    set y, DATA_BITS
sample_byte_loop:
    in pins, 1 [7]              ; Sample bit at its center, total 10 cycles/bit.
    nop
    jmp y-- sample_byte_loop

    ; --- Byte complete. ---
    ; After sampling 8 bits (80 cycles) + the BSS '0' bit (10 cycles) + the
    ; BSS '1' bit (10 cycles), a total of 100 cycles have passed since the
    ; *previous* BSS falling edge. We are now perfectly aligned with the start
    ; of the current byte's BSS '1' bit. We can immediately start searching.
    jmp find_bss_entry_point

flush_isr:
    ; --- 6. ISR Flush Routine ---
    ; The ISR contains the last partial word. We shift in 32 zeros to
    ; force a final autopush, ensuring all valid data is sent.
    set y, FLUSH_COUNT          ; Loop 32 times.
flush_loop:
    in null, 1                  ; 1 cycle: Shift a '0' into the MSB of the ISR.
    jmp y-- flush_loop          ; 1 cycle: Loop until ISR is flushed.

frame_end:
    push
    irq set 0
    jmp entry_point

% c-sdk {

void flexray_bss_streamer_program_init(PIO pio, uint sm, uint offset, uint rx_pin, uint debug_pin) {
    // --- GPIO Configuration: Must be done BEFORE pio_gpio_init() ---
    // Enable pull-up on the FlexRay RX pin to ensure it's high when idle.
    gpio_pull_up(rx_pin);

    // Now, let PIO take control of the pins.
    pio_gpio_init(pio, rx_pin);
    pio_gpio_init(pio, debug_pin);

    pio_sm_set_consecutive_pindirs(pio, sm, rx_pin, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, debug_pin, 1, true);
    pio_sm_config c = flexray_bss_streamer_program_get_default_config(offset);

    sm_config_set_in_pins(&c, rx_pin);
    sm_config_set_jmp_pin(&c, rx_pin);
    sm_config_set_sideset_pins(&c, debug_pin);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    // oversample by 10, 10MHz flexray bit rate, 100MHz clock
    float div = (float)clock_get_hz(clk_sys) / (10 * 1000000 * 10);
    sm_config_set_clkdiv(&c, div);
    sm_config_set_in_shift(&c, false, true, 32); // BSS is MSB first, Shift left, autopush
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

%}
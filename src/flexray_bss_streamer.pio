; A PIO program that continuously finds FlexRay frames, streams them,
; and raises an interrupt after each one, without ever stopping.

.program flexray_bss_streamer
; .side_set 1 opt ; Side-set pin 0 is used to control the transmitter enable (TX_EN)

.define public IDLE_COUNT 10     ; For 11 * 10 = 110 cycle initial idle check.
; Set timeout counter to 31 (max value for a 5-bit immediate).
; This allows for 32 iterations of the 2-cycle polling loop, giving a
; timeout of 64 PIO cycles (~6.4 FlexRay bit times). This is ample
; time to find a BSS and a robust threshold for detecting EOP.
.define public BSS_SEARCH_TIMEOUT 31
.define public FLUSH_COUNT 31

.define public DATA_BITS 7       ; Loop 8 times for 8 bits.

.wrap_target
entry_point:
    ; mov isr, null
    set x, IDLE_COUNT
    ; --- 1. Initial Bus Idle Check ---
    ; this loop does not need to be aligned to the center of the bit window.
    ; it only detects 11 bits high, the wait will catch the edge.
idle_loop:
    jmp pin is_high [8]
    jmp entry_point
is_high:
    jmp x-- idle_loop
    ; idle: 11bit
    ; tss: 5-15bit high
    ; fss: 1bit high
    ; bss: 1 high 1 low
    ;      idle   tss        fbss
    ; ¯¯¯¯¯¯¯¯¯¯¯|__________|¯¯|_|¯|_

    ; --- 2. Frame Start Synchronization (TSS/FSS) ---
    wait 0 pin 0                ; waiting for TSS low
    wait 1 pin 0                ; before FSS high detected, we are in TSS
    nop [9]                     ; consume fss high
    ; --- 3. Entry point for finding any BSS (first or subsequent) ---
    ; avoid stall by low pin.
find_bss_entry_point:
    ; Prime the timeout counter for the high-speed search.
    set x, BSS_SEARCH_TIMEOUT   ; 1 cycle for BSS high

    ; --- 4. High-Frequency (50MHz) Polling Loop for BSS Falling Edge ---
find_edge_loop:
    jmp pin high_path           ; 1 cycle. If pin is HIGH, jump.
    ; --- PATH FOR LOW BIT (Edge Found!) ---
    jmp found_edge              ; 1 cycle. If pin is LOW, we found the edge!

high_path:
    jmp x-- find_edge_loop      ; 1 cycle. Pin was HIGH, decrement timeout, loop again.
    ; --- EOP DETECTED (Timeout) ---
    ; 'jmp x--' failed. We searched for ~6 bit times without finding a falling edge.
    ; jmp frame_end
    jmp flush_isr               ; frame end.

found_edge:
    ; --- SYNC POINT! ---
    ; We have a high-precision sync point at the start of a BSS '0' bit.
    ; The path to get here took 2 cycles (`jmp pin` fail + `jmp found_edge`).
    ; To sample in the center of the NEXT data bit (1.5 bits = 15 cycles away),
    ; we need to wait 15 - 2 = 13 cycles.
    ; 1st or 2nd of the over-sampled low state for BSS
    nop [12]                    ; Wait 13 cycles.

    ; --- 5. Synchronized 8-Bit Byte Sample ---
    set y, DATA_BITS
sample_byte_loop:
    in pins, 1 [7]              ; Sample bit at its center, total 10 cycles/bit.
    jmp y-- sample_byte_loop [1]

    ; --- Byte complete. ---
    ; After sampling 8 bits (80 cycles) + the BSS '0' bit (10 cycles) + the
    ; BSS '1' bit (10 cycles), a total of 100 cycles have passed since the
    ; *previous* BSS falling edge. We are now perfectly aligned with the start
    ; of the current byte's BSS '1' bit. We can immediately start searching.
    set x, BSS_SEARCH_TIMEOUT   ; Reuse the timeout counter.
wait_bss_high_loop:             ; Avoid stall by low pin.
    jmp pin high_path           ; If pin is high, the bus is in a good state.
    jmp x-- wait_bss_high_loop  ; Otherwise, decrement counter and re-check.
    jmp flush_isr               ; If we timeout, the bus is stuck low. Abort.

flush_isr:
    ; --- 6. ISR Flush Routine ---
    ; The ISR contains the last partial word. We shift in 32 zeros to
    ; force a final autopush, ensuring all valid data is sent.
    set y, FLUSH_COUNT          ; Loop 32 times. Yield bus by TX_EN=0
                                ; It's ok to side set at here, we have 10x oversampling.
flush_loop:
    in null, 1                  ; 1 cycle: Shift a '0' into the MSB of the ISR.
    jmp y-- flush_loop          ; 1 cycle: Loop until ISR is flushed.

frame_end:
    push
    irq set 0
.wrap

% c-sdk {

void flexray_bss_streamer_program_init(PIO pio, uint sm, uint offset, uint rx_pin, uint tx_en_pin) {
    // --- GPIO Configuration: Must be done BEFORE pio_gpio_init() ---
    // Enable pull-up on the FlexRay RX pin to ensure it's high when idle.
    gpio_pull_up(rx_pin);

    // Now, let PIO take control of the pins.
    pio_gpio_init(pio, rx_pin);
    ; pio_gpio_init(pio, tx_en_pin);

    pio_sm_set_consecutive_pindirs(pio, sm, rx_pin, 1, false);
    ; pio_sm_set_consecutive_pindirs(pio, sm, tx_en_pin, 1, true);
    pio_sm_config c = flexray_bss_streamer_program_get_default_config(offset);

    sm_config_set_in_pins(&c, rx_pin);
    sm_config_set_jmp_pin(&c, rx_pin);
    ; sm_config_set_sideset_pins(&c, tx_en_pin);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    // oversample by 10, 10MHz flexray bit rate, 100MHz clock
    float div = (float)clock_get_hz(clk_sys) / (10 * 1000000 * 10);
    sm_config_set_clkdiv(&c, div);
    sm_config_set_in_shift(&c, false, true, 32); // BSS is MSB first, Shift left, autopush
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

%}